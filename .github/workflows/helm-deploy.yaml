---
name: Helm Deploy Triton Platform + Monitoring

on:
  workflow_run:
    workflows: ["Terraform Infra Provision"]
    types:
      - completed

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  AWS_DEFAULT_REGION: us-east-1
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
  TRITON_NAMESPACE: triton
  MONITORING_NAMESPACE: monitoring
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


jobs:

  deploy:
    name: Deploy Triton + Monitoring Stack
    runs-on: ubuntu-latest
    environment: production

    steps:
      # ------------------------------
      # CHECKOUT
      # ------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4

      # ------------------------------
      # AWS Auth via OIDC
      # ------------------------------
      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com
          output-env-credentials: true

      # ------------------------------
      # Install CLI Tools
      # ------------------------------
      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install Helm
        uses: azure/setup-helm@v3
      # ------------------------------
      # Setup Terraform
      # ------------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.3  # Change to your required version

      # ------------------------------
      # export terraform outputs
      # ------------------------------
      - name: Export Terraform outputs
        run: |
          TF_DIR="infra/terraform"

          # initialize terraform for outputs to work
          terraform -chdir="$TF_DIR" init -input=false

          CLUSTER_NAME=$(terraform -chdir="TF_DIR" \
            output -raw eks_cluster_name)

          echo "EKS_CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV

      # ------------------------------
      # update Kubeconfig for EKS
      # ------------------------------
      - name: update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region us-east-1 \
            --name "$EKS_CLUSTER_NAME"

          kubectl config view
          kubectl get nodes

      - name: Verify K8s Connection
        run: |
          kubectl get nodes

      - name: Create Alertmanager Secret
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: ${{ secrets.SLACK_CHANNEL }}
        run: |
          set -e

          # Delete old secret if exists
          kubectl -n "${MONITORING_NAMESPACE}" delete secret \
            alertmanager-main --ignore-not-found

          # Create new secret with inline YAML
          kubectl -n "${MONITORING_NAMESPACE}" create secret generic \
            alertmanager-main \
            --from-literal=api_url="${SLACK_WEBHOOK_URL}" \
            --from-literal=channel="${SLACK_CHANNEL}"

      # ------------------------------
      # Wait for monitoring stack (terraform-managed prometheus stack)
      # ------------------------------
      - name: Wait for Prometheus Operator readiness
        run: |
          set -e
          echo "Waiting for Prometheus Operator..."

          kubectl -n "${MONITORING_NAMESPACE}" rollout status \
            deployment/kube-prometheus-stack-operator \
            --timeout=5m || {

             echo "Main operator name not found, trying fallback..."

             kubectl -n "${MONITORING_NAMESPACE}" rollout status \
               deployment/prometheus-operator \
               --timeout=5m
            }

      # ------------------------------
      # DEPLOY TRITON (Helm Chart Generated)
      # ------------------------------
      - name: Deploy Triton Inference Server
        run: |
          set -e
          helm upgrade --install triton \
            ./services/triton/helm \
            --namespace "${TRITON_NAMESPACE}" \
            --create-namespace \
            -f services/triton/helm/values.yaml

      - name: Wait for Triton Deployment
        run: |
          set -e
          echo "Waiting for Triton deployment..."
          kubectl -n "${TRITON_NAMESPACE}" rollout status \
            deployment/triton \
            --timeout=5m

      # ------------------------------
      # NVIDIA DCGM Exporter (GPU Metrics)
      # ------------------------------
      - name: Deploy NVIDIA DCGM Exporter
        run: |
          set -e
          helm repo add nvidia https://nvidia.github.io/dcgm-exporter
          helm repo update
          helm upgrade --install dcgm-exporter \
            nvidia/dcgm-exporter \
            --namespace "${MONITORING_NAMESPACE}" \
            --create-namespace

      # ------------------------------
      # DONE
      # ------------------------------
      - name: Complete
        run: echo "Triton + Monitoring stack deployed successfully!"
